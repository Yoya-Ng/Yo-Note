[["Map",1,2,9,10],"meta::meta",["Map",3,4,5,6,7,8],"astro-version","5.3.0","content-config-digest","e2d69c693959d5f1","astro-config-digest","{\"root\":{},\"srcDir\":{},\"publicDir\":{},\"outDir\":{},\"cacheDir\":{},\"site\":\"https://astro-myblog.netlify.app\",\"compressHTML\":true,\"base\":\"/\",\"trailingSlash\":\"ignore\",\"output\":\"static\",\"scopedStyleStrategy\":\"attribute\",\"build\":{\"format\":\"directory\",\"client\":{},\"server\":{},\"assets\":\"_astro\",\"serverEntry\":\"entry.mjs\",\"redirects\":true,\"inlineStylesheets\":\"auto\",\"concurrency\":1},\"server\":{\"open\":false,\"host\":false,\"port\":4321,\"streaming\":true},\"redirects\":{},\"image\":{\"endpoint\":{\"route\":\"/_image\"},\"service\":{\"entrypoint\":\"astro/assets/services/sharp\",\"config\":{}},\"domains\":[],\"remotePatterns\":[]},\"devToolbar\":{\"enabled\":false},\"markdown\":{\"syntaxHighlight\":\"shiki\",\"shikiConfig\":{\"langs\":[],\"langAlias\":{},\"theme\":\"github-dark\",\"themes\":{},\"wrap\":false,\"transformers\":[]},\"remarkPlugins\":[],\"rehypePlugins\":[],\"remarkRehype\":{},\"gfm\":true,\"smartypants\":true},\"i18n\":{\"defaultLocale\":\"en\",\"locales\":[\"es\",\"en\",\"pt-br\"],\"routing\":{\"prefixDefaultLocale\":false,\"redirectToDefaultLocale\":true,\"fallbackType\":\"redirect\"}},\"security\":{\"checkOrigin\":true},\"env\":{\"schema\":{},\"validateSecrets\":false},\"experimental\":{\"clientPrerender\":false,\"contentIntellisense\":false,\"responsiveImages\":false,\"serializeConfig\":false},\"legacy\":{\"collections\":false}}","blog",["Map",11,12,53,54,115,116,135,136,221,222],"post-3",{"id":11,"data":13,"body":26,"filePath":27,"digest":28,"rendered":29},{"title":14,"pubDate":15,"description":16,"author":17,"image":18,"tags":21},"Java 17 新功能",["Date","2022-07-15T00:00:00.000Z"],"I had some challenges, but asking in the community really helped!","Astro Learner",{"url":19,"alt":20},"https://docs.astro.build/assets/rays.webp","The Astro logo on a dark background with rainbow rays.",[22,23,24,25],"astro","learning in public","setbacks","community","- [比較圖](#比較圖)\n- [sealed 限制繼承](#sealed-限制繼承)\n- [record 取代傳統 POJO](#record-取代傳統-pojo)\n- [switch 模式匹配](#switch-模式匹配)\n- [Text Blocks 簡化多行字串](#text-blocks-簡化多行字串)\n\n### 比較圖\n\n![alt text](/Comparison_Chart.png)\n\n### sealed 限制繼承\n\n![alt text](/java_sealed.png)\n\n### record 取代傳統 POJO\n\n![alt text](/java_record.png)\n\n### switch 模式匹配\n\n![alt text](/java_switch.png)\n\n### Text Blocks 簡化多行字串\n\n![alt text](\u003C/java_text Blocks.png>)","src/blog/post-3.md","06fcf6071383bfe5",{"html":30,"metadata":31},"\u003Cul>\n\u003Cli>\u003Ca href=\"#%E6%AF%94%E8%BC%83%E5%9C%96\">比較圖\u003C/a>\u003C/li>\n\u003Cli>\u003Ca href=\"#sealed-%E9%99%90%E5%88%B6%E7%B9%BC%E6%89%BF\">sealed 限制繼承\u003C/a>\u003C/li>\n\u003Cli>\u003Ca href=\"#record-%E5%8F%96%E4%BB%A3%E5%82%B3%E7%B5%B1-pojo\">record 取代傳統 POJO\u003C/a>\u003C/li>\n\u003Cli>\u003Ca href=\"#switch-%E6%A8%A1%E5%BC%8F%E5%8C%B9%E9%85%8D\">switch 模式匹配\u003C/a>\u003C/li>\n\u003Cli>\u003Ca href=\"#text-blocks-%E7%B0%A1%E5%8C%96%E5%A4%9A%E8%A1%8C%E5%AD%97%E4%B8%B2\">Text Blocks 簡化多行字串\u003C/a>\u003C/li>\n\u003C/ul>\n\u003Ch3 id=\"比較圖\">比較圖\u003C/h3>\n\u003Cp>\u003Cimg src=\"/Comparison_Chart.png\" alt=\"alt text\">\u003C/p>\n\u003Ch3 id=\"sealed-限制繼承\">sealed 限制繼承\u003C/h3>\n\u003Cp>\u003Cimg src=\"/java_sealed.png\" alt=\"alt text\">\u003C/p>\n\u003Ch3 id=\"record-取代傳統-pojo\">record 取代傳統 POJO\u003C/h3>\n\u003Cp>\u003Cimg src=\"/java_record.png\" alt=\"alt text\">\u003C/p>\n\u003Ch3 id=\"switch-模式匹配\">switch 模式匹配\u003C/h3>\n\u003Cp>\u003Cimg src=\"/java_switch.png\" alt=\"alt text\">\u003C/p>\n\u003Ch3 id=\"text-blocks-簡化多行字串\">Text Blocks 簡化多行字串\u003C/h3>\n\u003Cp>\u003Cimg src=\"/java_text Blocks.png\" alt=\"alt text\">\u003C/p>",{"headings":32,"imagePaths":48,"frontmatter":49},[33,36,39,42,45],{"depth":34,"slug":35,"text":35},3,"比較圖",{"depth":34,"slug":37,"text":38},"sealed-限制繼承","sealed 限制繼承",{"depth":34,"slug":40,"text":41},"record-取代傳統-pojo","record 取代傳統 POJO",{"depth":34,"slug":43,"text":44},"switch-模式匹配","switch 模式匹配",{"depth":34,"slug":46,"text":47},"text-blocks-簡化多行字串","Text Blocks 簡化多行字串",[],{"title":14,"author":17,"description":16,"image":50,"pubDate":51,"tags":52},{"url":19,"alt":20},["Date","2022-07-15T00:00:00.000Z"],[22,23,24,25],"post-5",{"id":53,"data":55,"body":63,"filePath":64,"digest":65,"rendered":66},{"title":56,"pubDate":57,"description":58,"author":17,"image":59,"tags":62},"other",["Date","2022-08-08T00:00:00.000Z"],"This post will show up on its own!",{"url":60,"alt":61},"https://docs.astro.build/default-og-image.png","The word astro against an illustration of planets and stars.",[22],"# 什麼是物件導向？\n\n一種設計模式，透過 **封裝 繼承 多型** 來提高可讀性 可維護性 可擴展性\n封裝 將屬性和方法封裝載物件內，只提供介面給外部使用\n繼承 讓子類別繼承父類別的方法 提高程式的可重用性\n多形 讓不同類別的物件對相同方法有不同的實作\n\n# Spring framework\n\n一種輕量級的框架\nIOC:控制反轉，透過框架管理物件的建立與生命週期，降低耦合度\nDI:依賴注入，將物件的依賴透過外部注入，提高可維護性和測試性\nAOP:切面控制，可做到權限管控，事務管理 日記管理\n\n# 什麼是 Spring Boot？\n\n一個框架，可讓開發者快速建置 spring，內含 tomcat，適合微服務開發\n\n# JPA 是什麼？\n\n一個規範，定義了物件關係映射\n\n# ORM 是什麼？\n\n一個技術用於提升開發效率，減少手寫ＳＱＬ，包含 spring data jpa hibernate mybatis\n\n# Spring JDBC\n\n簡化ＪＡＶＡ原生ＪＤＢＣ ＡＰＩ的套件\n\n# Spring Data JPA\n\n簡化資料庫存取，透過 Repository 操作ＣＲＵＤ，無須手寫ＳＱＬ，自由度低無法做複查的查詢\n\n# Hibernate\n\n使用ＨＱＬ或原生ＳＱＬ的方式完成ＣＲＵＤ，可手寫ＳＱＬ\n\n# MyBatis\n\n透過ＸＭＬ或註解定義ＳＱＬ，需手寫ＳＱＬ\n\n# Redis\n\n一個快取，可降低資料庫的附載\n\n# Tomcat 和 JBoss 有什麼區別？\n\ntomcat 支援 servlet JSP\njboss 是企業級的 Java EE\n\n# 微服務（Microservices）\n\n一種架構模式，每個服務可個獨立部署 擴展\n\n# 雲服務（Cloud Services）\n\nIBM Cloud\nAmazon Web Services（AWS）","src/blog/post-5.md","8f145b98aa38df96",{"html":67,"metadata":68},"\u003Ch1 id=\"什麼是物件導向\">什麼是物件導向？\u003C/h1>\n\u003Cp>一種設計模式，透過 \u003Cstrong>封裝 繼承 多型\u003C/strong> 來提高可讀性 可維護性 可擴展性\n封裝 將屬性和方法封裝載物件內，只提供介面給外部使用\n繼承 讓子類別繼承父類別的方法 提高程式的可重用性\n多形 讓不同類別的物件對相同方法有不同的實作\u003C/p>\n\u003Ch1 id=\"spring-framework\">Spring framework\u003C/h1>\n\u003Cp>一種輕量級的框架\nIOC:控制反轉，透過框架管理物件的建立與生命週期，降低耦合度\nDI:依賴注入，將物件的依賴透過外部注入，提高可維護性和測試性\nAOP:切面控制，可做到權限管控，事務管理 日記管理\u003C/p>\n\u003Ch1 id=\"什麼是-spring-boot\">什麼是 Spring Boot？\u003C/h1>\n\u003Cp>一個框架，可讓開發者快速建置 spring，內含 tomcat，適合微服務開發\u003C/p>\n\u003Ch1 id=\"jpa-是什麼\">JPA 是什麼？\u003C/h1>\n\u003Cp>一個規範，定義了物件關係映射\u003C/p>\n\u003Ch1 id=\"orm-是什麼\">ORM 是什麼？\u003C/h1>\n\u003Cp>一個技術用於提升開發效率，減少手寫ＳＱＬ，包含 spring data jpa hibernate mybatis\u003C/p>\n\u003Ch1 id=\"spring-jdbc\">Spring JDBC\u003C/h1>\n\u003Cp>簡化ＪＡＶＡ原生ＪＤＢＣ ＡＰＩ的套件\u003C/p>\n\u003Ch1 id=\"spring-data-jpa\">Spring Data JPA\u003C/h1>\n\u003Cp>簡化資料庫存取，透過 Repository 操作ＣＲＵＤ，無須手寫ＳＱＬ，自由度低無法做複查的查詢\u003C/p>\n\u003Ch1 id=\"hibernate\">Hibernate\u003C/h1>\n\u003Cp>使用ＨＱＬ或原生ＳＱＬ的方式完成ＣＲＵＤ，可手寫ＳＱＬ\u003C/p>\n\u003Ch1 id=\"mybatis\">MyBatis\u003C/h1>\n\u003Cp>透過ＸＭＬ或註解定義ＳＱＬ，需手寫ＳＱＬ\u003C/p>\n\u003Ch1 id=\"redis\">Redis\u003C/h1>\n\u003Cp>一個快取，可降低資料庫的附載\u003C/p>\n\u003Ch1 id=\"tomcat-和-jboss-有什麼區別\">Tomcat 和 JBoss 有什麼區別？\u003C/h1>\n\u003Cp>tomcat 支援 servlet JSP\njboss 是企業級的 Java EE\u003C/p>\n\u003Ch1 id=\"微服務microservices\">微服務（Microservices）\u003C/h1>\n\u003Cp>一種架構模式，每個服務可個獨立部署 擴展\u003C/p>\n\u003Ch1 id=\"雲服務cloud-services\">雲服務（Cloud Services）\u003C/h1>\n\u003Cp>IBM Cloud\nAmazon Web Services（AWS）\u003C/p>",{"headings":69,"imagePaths":110,"frontmatter":111},[70,74,77,80,83,86,89,92,95,98,101,104,107],{"depth":71,"slug":72,"text":73},1,"什麼是物件導向","什麼是物件導向？",{"depth":71,"slug":75,"text":76},"spring-framework","Spring framework",{"depth":71,"slug":78,"text":79},"什麼是-spring-boot","什麼是 Spring Boot？",{"depth":71,"slug":81,"text":82},"jpa-是什麼","JPA 是什麼？",{"depth":71,"slug":84,"text":85},"orm-是什麼","ORM 是什麼？",{"depth":71,"slug":87,"text":88},"spring-jdbc","Spring JDBC",{"depth":71,"slug":90,"text":91},"spring-data-jpa","Spring Data JPA",{"depth":71,"slug":93,"text":94},"hibernate","Hibernate",{"depth":71,"slug":96,"text":97},"mybatis","MyBatis",{"depth":71,"slug":99,"text":100},"redis","Redis",{"depth":71,"slug":102,"text":103},"tomcat-和-jboss-有什麼區別","Tomcat 和 JBoss 有什麼區別？",{"depth":71,"slug":105,"text":106},"微服務microservices","微服務（Microservices）",{"depth":71,"slug":108,"text":109},"雲服務cloud-services","雲服務（Cloud Services）",[],{"title":56,"author":17,"description":58,"image":112,"pubDate":113,"tags":114},{"url":60,"alt":61},["Date","2022-08-08T00:00:00.000Z"],[22],"post-4",{"id":115,"data":117,"body":123,"filePath":124,"digest":125,"rendered":126},{"title":118,"pubDate":119,"description":58,"author":17,"image":120,"tags":121},"test",["Date","2022-08-08T00:00:00.000Z"],{"url":60,"alt":61},[22,122],"successes","This post should show up with my other blog posts, because `import.meta.glob()` is returning a list of all my posts in order to create my list.","src/blog/post-4.md","c8ccd73462bd99e1",{"html":127,"metadata":128},"\u003Cp>This post should show up with my other blog posts, because \u003Ccode>import.meta.glob()\u003C/code> is returning a list of all my posts in order to create my list.\u003C/p>",{"headings":129,"imagePaths":130,"frontmatter":131},[],[],{"title":118,"author":17,"description":58,"image":132,"pubDate":133,"tags":134},{"url":60,"alt":61},["Date","2022-08-08T00:00:00.000Z"],[22,122],"post-2",{"id":135,"data":137,"body":146,"filePath":147,"digest":148,"rendered":149},{"title":138,"pubDate":139,"description":140,"author":17,"image":141,"tags":144},"Java Knowledge",["Date","2022-07-08T00:00:00.000Z"],"",{"url":142,"alt":143},"https://docs.astro.build/assets/arc.webp","The Astro logo on a dark background with a purple gradient arc.",[22,145,23,122],"blogging","- [什麼是 OOP 物件導向？](#什麼是-oop-物件導向)\n- [Spring framework](#spring-framework)\n- [什麼是 Spring Boot？](#什麼是-spring-boot)\n- [JPA 是什麼？](#jpa-是什麼)\n  - [ORM 是什麼？](#orm-是什麼)\n    - [Spring JDBC](#spring-jdbc)\n    - [Spring Data JPA](#spring-data-jpa)\n    - [Hibernate](#hibernate)\n    - [MyBatis](#mybatis)\n- [Redis](#redis)\n- [語法相關問題](#語法相關問題)\n  - [== 和 .equals() 的區別？](#-和-equals-的區別)\n  - [Java 中 final, finally, finalize 的區別？](#java-中-final-finally-finalize-的區別)\n  - [String, StringBuilder, StringBuffer 的區別 ?](#string-stringbuilder-stringbuffer-的區別-)\n  - [int \\& integer 差別?](#int--integer-差別)\n  - [Java 8 引入的流（Stream）是什麼？](#java-8-引入的流stream是什麼)\n  - [什麼是 Lambda 表達式？有什麼優點？](#什麼是-lambda-表達式有什麼優點)\n  - [什麼是集合？](#什麼是集合)\n  - [－－－待處理](#待處理)\n  - [多執行緒和併發問題](#多執行緒和併發問題)\n  - [synchronized 和 Lock 的區別？](#synchronized-和-lock-的區別)\n  - [JVM?](#jvm)\n- [微服務（Microservices）](#微服務microservices)\n- [雲服務（Cloud Services）](#雲服務cloud-services)\n- [Tomcat 和 JBoss 有什麼區別？](#tomcat-和-jboss-有什麼區別)\n- [什麼事 設計模式（Design Pattern）?](#什麼事-設計模式design-pattern)\n  - [1.創建型模式（Creational Patterns）](#1創建型模式creational-patterns)\n  - [2.結構型模式（Structural Patterns）](#2結構型模式structural-patterns)\n  - [3.行為型模式（Behavioral Patterns）](#3行為型模式behavioral-patterns)\n\n## 什麼是 OOP 物件導向？\n\n- 封裝\n- 繼承\n- 多型\n\n## Spring framework\n\n- Spring 是一個開源的應用框架，旨在簡化 Java 應用程式的開發，提供控制反轉（IoC）和依賴注入（DI）等功能。\n\n1. 控制反轉 (IoC)\n   - 什麼是 IoC ？\n     - IoC 容器負責管理對象的生命週期和依賴關係。\n2. 依賴注入（DI）\n   - 什麼是 DI？\n     - 依賴注入是一種設計模式，通過將對象的依賴關係在運行時注入到對象中來減少耦合。\n3. AOP (面向切面編程)\n   - 什麼是 AOP？\n     - AOP 是一種編程範式，用於將橫切關心（如日誌、安全性）與業務邏輯分離。\n\n## 什麼是 Spring Boot？\n\n- Spring Boot 是 Spring 的延伸，目標是讓開發者能夠快速建立 Spring 應用程式，而不需要處理大量的配置。它內建 Web 伺服器、自動配置、簡化依賴管理，適合用來開發 微服務（Microservices） 或 獨立應用。\n- 理解核心概念：熟悉 IoC（控制反轉）、DI（依賴注入）、AOP（面向切面編程）等基礎知識。\n\n## JPA 是什麼？\n\n> 一個 ORM 的規範，不包含具體實作。  \n> 通過映射 Java 物件與資料庫表格，使開發者能夠輕鬆處理資料庫操作。核心包括 EntityManager、JPQL、事務管理 等，能大幅簡化 Java 應用中的資料持久化工作，  \n> 並且能與不同的 ORM 實現（如 Hibernate）兼容。\n\n1. **EntityManager**：JPA 的核心介面，負責對實體進行 CRUD 操作。\n2. **JPQL（Java Persistence Query Language）**：類似 SQL 的查詢語言，但基於 Java 實體而非資料庫表。\n3. **事務管理（Transaction Management）**：JPA 支援透過 @Transactional 來管理事務，確保資料一致性。\n4. **不同的實現**：JPA 只是規範，常見的實作有 Hibernate、EclipseLink、OpenJPA 等。\n\n### ORM 是什麼？\n\n> JPA（Java Persistence API） – 規範\n\n    Spring Data JPA － Spring 提供的一個數據訪問抽象\n    Hibernate – 最流行的 JPA 實作，ORM 實作\n    MyBatis – SQL Mapper\n    OpenJPA – JPA 另一種實作\n    EclipseLink – JPA 官方參考實作\n\n#### Spring JDBC\n\n- 概念：提供直接訪問數據庫的方式，使用 JdbcTemplate 類來執行 SQL 語句，並映射查詢結果。\n\n#### Spring Data JPA\n\n- JPA 抽象層，簡化數據訪問\n- 自動生成查詢，靈活度稍低\n- 項目與 Spring 生態系統深度集成。\n\n#### Hibernate\n\n- 具體的 ORM 實作\n- 手寫 HQL/SQL，靈活度高\n- 使用 Hibernate 原生的 HQL、Criteria API 或原生 SQL\n\n#### MyBatis\n\n- SQL Mapper（SQL 映射工具）\n- 需要完全控制 SQL 語句。\n- 項目中存在大量複雜查詢或性能優化需求。\n- 需寫 XML\n\n## Redis\n\n1.  主要用途：Redis 是一個內存型數據存儲系統，主要用於快取、即時分析和簡單的消息系統。\n2.  數據結構支持：支持多種數據結構（如字符串、哈希、列表、集合、有序集合等），靈活處理不同類型的數據。\n3.  高性能：基於內存操作，讀寫速度極快，適合需要低延遲的場景。\n4.  Pub/Sub 模型：提供基本的發布/訂閱功能，但不具備 RabbitMQ 的高級功能（如持久化和路由）。\n5.  多功能性：除了作為消息系統，還可用作快取層、會話存儲或即時分析工具。\n\n## 語法相關問題\n\n#### == 和 .equals() 的區別？\n\n- == 比較的是 記憶體地址（基本類型、引用類型）。\n- .equals() 預設等價於 ==，但在 String 和 Integer 等類中 被重寫，比較的是內容。\n\n#### Java 中 final, finally, finalize 的區別？\n\n- final：用於 變數、方法、類，不可變或不可重寫。\n- finally：用於 try-catch-finally，確保程式塊執行。\n- ~~finalize()：垃圾回收前執行，已被淘汰（JDK 9 棄用）。~~\n\n#### String, StringBuilder, StringBuffer 的區別 ?\n\n- String - String Pool（字串池機制）\n  - ❌ 不可變\n  - ✅ 安全（不可變）\n  - 字串不會頻繁變化\n- StringBuilder\n  - ✅ 可變\n  - ❌ 不安全\n  - 單執行緒、大量字串操作\n- StringBuffer\n  - ✅ 可變\n  - ✅ 安全（同步鎖）\n  - 多執行緒、大量字串操作\n\n#### int & integer 差別?\n\n- 基本資料類型 vs 物件類型\n\n#### Java 8 引入的流（Stream）是什麼？\n\n- 更高效的集合操作方式，如過濾、映射、排序等。\n\n#### 什麼是 Lambda 表達式？有什麼優點？\n\n- 一種簡化函數式編程的方式，使得代碼更加簡潔。\n\n#### 什麼是集合？\n\n- List 可重複，有序\n  - ArrayList（動態陣列，查詢快，增刪慢）\n  - LinkedList（鏈結串列，增刪快，查詢慢）\n  - Vector（類似 ArrayList，但執行緒安全）\n- Set 不可重複，無序\n  - HashSet（基於 HashTable，不保證順序）\n  - TreeSet（基於 紅黑樹，元素有序）\n  - LinkedHashSet（維持插入順序）\n- Map （Key-Value)\n  - HashMap（最快，但無序）\n  - TreeMap（Key 有序）\n  - LinkedHashMap（維持插入順序）\n\n#### －－－待處理\n\n#### 多執行緒和併發問題\n\n#### synchronized 和 Lock 的區別？\n\n- synchronized：內建鎖，自動釋放，效能較低。\n- Lock（如 ReentrantLock）：手動釋放，支援可重入、超時等待、公平鎖等特性。\n\n#### JVM?\n\n## 微服務（Microservices）\n\n> 微服務是一種架構模式\n\n- 每個微服務都是獨立的，可以獨立開發、測試、部署。\n- Spring Boot / Spring Cloud：用於快速開發和集成微服務的框架。\n- Docker：提供容器化環境來部署微服務，確保每個微服務可以在任何環境中一致運行。\n- Kubernetes：提供容器編排平台，用於管理微服務的部署、擴展和運行。\n\n## 雲服務（Cloud Services）\n\n- Amazon Web Services (AWS)：\n  - 全球最大的雲服務提供商，提供各種 IaaS、PaaS 和 SaaS 服務，涵蓋計算、存儲、網絡、人工智能等領域。\n- Microsoft Azure：\n  - 微軟的雲平台，提供全面的雲計算服務，並與微軟的企業軟件（如 Windows Server、SQL Server）無縫集成。\n- IBM Cloud：\n  - IBM 提供的雲服務平台，專注於企業級解決方案，支持 AI、機器學習、區塊鏈等技術。\n\n## Tomcat 和 JBoss 有什麼區別？\n\n- Tomcat：\n  - Tomcat 是一個 Web 伺服器 和 Servlet 容器，Tomcat 適合用於需要輕量級的 Web 應用部署和運行，適合簡單的 Servlet/JSP 應用。\n- JBoss（現名為 WildFly）：\n  - JBoss 提供了一個完整的企業級解決方案，支持分佈式架構、事務處理和消息驅動等功能，適合大型企業應用和多層架構。\n  - 提供了對 EJB、JPA、JMS、JTA 等企業級技術的完整支援，適用於開發和部署企業級應用\n\n| Java EE 的核心技術                       | 說明                                            |\n| ---------------------------------------- | ----------------------------------------------- | ----------- |\n| Servlet                                  | 負責處理 HTTP 請求和回應，動態產生網頁內容      |\n| JSP（JavaServer Pages）                  | 讓開發者能在 HTML 中嵌入 Java 代碼              |\n| JSF（JavaServer Faces）                  | 企業級 Web UI 框架，類似於 Angular / React      |\n| JPA（Java Persistence API）              | ORM 框架，用來管理數據庫（類似                  | Hibernate） |\n| JTA（Java Transaction API）              | 負責分散式交易管理（確保資料一致性）            |\n| EJB（Enterprise JavaBeans）              | 負責商業邏輯，支援事務管理                      |\n| JMS（Java Message Service）              | 提供訊息佇列（Message Queue）功能               |\n| CDI（Contexts and Dependency Injection） | 依賴注入（類似 Spring 的 Dependency Injection） |\n\n---\n\n## 什麼事 設計模式（Design Pattern）?\n\n計模式通常分為三大類：\n\n### 1.創建型模式（Creational Patterns）\n\n> 這些模式主要解決如何將對象或類組合成更大的結構，以達到更好的效率和更清晰的代碼結構。\n\n- 🔴 單例模式（Singleton Pattern）：\n  - 保證一個類只有一個實例，並提供一個全局的訪問點。\n- 🔴 工廠方法模式（Factory Method Pattern）：\n  - 定義一個用於創建對象的接口，讓子類決定具體實例化哪一個類。\n- 🔴 抽象工廠模式（Abstract Factory Pattern）：\n  - 提供一個創建一系列相關或相互依賴對象的接口，而無需指定具體類別。\n- 建造者模式（Builder Pattern）：\n  - 分步構建一個複雜的對象，將對象的構建過程與表示分離。\n- 原型模式（Prototype Pattern）：\n  - 通過複製現有的對象來創建新對象，而不是重新創建一個對象。\n\n### 2.結構型模式（Structural Patterns）\n\n> 這些模式主要解決如何將對象或類組合成更大的結構，以達到更好的效率和更清晰的代碼結構。\n\n- 適配器模式（Adapter Pattern）：\n  - 將一個類的接口轉換為客戶端所期望的另一種接口，讓原本接口不兼容的類可以合作無間。\n- 裝飾者模式（Decorator Pattern）：\n  - 動態地給一個對象添加額外的職責，提供比繼承更靈活的擴展機會。\n- 外觀模式（Facade Pattern）：\n  - 為一組接口提供一個統一的高層接口，使得子系統的使用者可以更容易地使用這些接口。\n- 橋接模式（Bridge Pattern）：\n  - 將抽象部分與實現部分分離，使得兩者可以獨立變化。\n- 組合模式（Composite Pattern）：\n  - 將對象組合成樹形結構來表示部分與整體的層次結構，讓客戶對單個物件和組合物件的使用具有一致性。\n- 享元模式（Flyweight Pattern）：\n  - 通過共享相同的對象來減少內存消耗，特別是在處理大量細粒度對象的情況下。\n\n### 3.行為型模式（Behavioral Patterns）\n\n> 這些模式主要關心對象或類之間的通信和交互，如何提高對象之間協作的靈活性和效率。\n\n- 🔴 策略模式（Strategy Pattern）：\n  - 定義一系列的算法，並將每個算法封裝起來，使得它們可以互換，讓算法的變化獨立於使用算法的客戶。\n- 模板方法模式（Template Method Pattern）：\n  - 定義一個操作中的算法骨架，將某些步驟延遲到子類中，使得子類可以重新定義某些算法步驟而不改變算法的結構。\n- 觀察者模式（Observer Pattern）：\n  - 定義了一種一對多的依賴關係，當一個對象改變狀態時，所有依賴於它的對象都會得到通知並自動更新。\n- 狀態模式（State Pattern）：\n  - 允許對象在其內部狀態改變時改變其行為，使得對象的行為會根據當前狀態來改變。\n- 責任鏈模式（Chain of Responsibility Pattern）：\n  - 為請求創建一個接收者的鏈，每個接收者都對請求做出處理或轉發，直到請求被處理為止。\n- 命令模式（Command Pattern）：\n  - 將請求封裝成對象，從而讓用戶對請求的發出者和接收者解耦。\n- 中介者模式（Mediator Pattern）：\n  - 定義一個對象來封裝一組對象之間的交互，使得這些對象不需要直接互相引用，從而使它們的耦合度降低。","src/blog/post-2.md","3cc59b2e0627dd12",{"html":150,"metadata":151},"\u003Cul>\n\u003Cli>\u003Ca href=\"#%E4%BB%80%E9%BA%BC%E6%98%AF-oop-%E7%89%A9%E4%BB%B6%E5%B0%8E%E5%90%91\">什麼是 OOP 物件導向？\u003C/a>\u003C/li>\n\u003Cli>\u003Ca href=\"#spring-framework\">Spring framework\u003C/a>\u003C/li>\n\u003Cli>\u003Ca href=\"#%E4%BB%80%E9%BA%BC%E6%98%AF-spring-boot\">什麼是 Spring Boot？\u003C/a>\u003C/li>\n\u003Cli>\u003Ca href=\"#jpa-%E6%98%AF%E4%BB%80%E9%BA%BC\">JPA 是什麼？\u003C/a>\n\u003Cul>\n\u003Cli>\u003Ca href=\"#orm-%E6%98%AF%E4%BB%80%E9%BA%BC\">ORM 是什麼？\u003C/a>\n\u003Cul>\n\u003Cli>\u003Ca href=\"#spring-jdbc\">Spring JDBC\u003C/a>\u003C/li>\n\u003Cli>\u003Ca href=\"#spring-data-jpa\">Spring Data JPA\u003C/a>\u003C/li>\n\u003Cli>\u003Ca href=\"#hibernate\">Hibernate\u003C/a>\u003C/li>\n\u003Cli>\u003Ca href=\"#mybatis\">MyBatis\u003C/a>\u003C/li>\n\u003C/ul>\n\u003C/li>\n\u003C/ul>\n\u003C/li>\n\u003Cli>\u003Ca href=\"#redis\">Redis\u003C/a>\u003C/li>\n\u003Cli>\u003Ca href=\"#%E8%AA%9E%E6%B3%95%E7%9B%B8%E9%97%9C%E5%95%8F%E9%A1%8C\">語法相關問題\u003C/a>\n\u003Cul>\n\u003Cli>\u003Ca href=\"#-%E5%92%8C-equals-%E7%9A%84%E5%8D%80%E5%88%A5\">== 和 .equals() 的區別？\u003C/a>\u003C/li>\n\u003Cli>\u003Ca href=\"#java-%E4%B8%AD-final-finally-finalize-%E7%9A%84%E5%8D%80%E5%88%A5\">Java 中 final, finally, finalize 的區別？\u003C/a>\u003C/li>\n\u003Cli>\u003Ca href=\"#string-stringbuilder-stringbuffer-%E7%9A%84%E5%8D%80%E5%88%A5-\">String, StringBuilder, StringBuffer 的區別 ?\u003C/a>\u003C/li>\n\u003Cli>\u003Ca href=\"#int--integer-%E5%B7%AE%E5%88%A5\">int &#x26; integer 差別?\u003C/a>\u003C/li>\n\u003Cli>\u003Ca href=\"#java-8-%E5%BC%95%E5%85%A5%E7%9A%84%E6%B5%81stream%E6%98%AF%E4%BB%80%E9%BA%BC\">Java 8 引入的流（Stream）是什麼？\u003C/a>\u003C/li>\n\u003Cli>\u003Ca href=\"#%E4%BB%80%E9%BA%BC%E6%98%AF-lambda-%E8%A1%A8%E9%81%94%E5%BC%8F%E6%9C%89%E4%BB%80%E9%BA%BC%E5%84%AA%E9%BB%9E\">什麼是 Lambda 表達式？有什麼優點？\u003C/a>\u003C/li>\n\u003Cli>\u003Ca href=\"#%E4%BB%80%E9%BA%BC%E6%98%AF%E9%9B%86%E5%90%88\">什麼是集合？\u003C/a>\u003C/li>\n\u003Cli>\u003Ca href=\"#%E5%BE%85%E8%99%95%E7%90%86\">－－－待處理\u003C/a>\u003C/li>\n\u003Cli>\u003Ca href=\"#%E5%A4%9A%E5%9F%B7%E8%A1%8C%E7%B7%92%E5%92%8C%E4%BD%B5%E7%99%BC%E5%95%8F%E9%A1%8C\">多執行緒和併發問題\u003C/a>\u003C/li>\n\u003Cli>\u003Ca href=\"#synchronized-%E5%92%8C-lock-%E7%9A%84%E5%8D%80%E5%88%A5\">synchronized 和 Lock 的區別？\u003C/a>\u003C/li>\n\u003Cli>\u003Ca href=\"#jvm\">JVM?\u003C/a>\u003C/li>\n\u003C/ul>\n\u003C/li>\n\u003Cli>\u003Ca href=\"#%E5%BE%AE%E6%9C%8D%E5%8B%99microservices\">微服務（Microservices）\u003C/a>\u003C/li>\n\u003Cli>\u003Ca href=\"#%E9%9B%B2%E6%9C%8D%E5%8B%99cloud-services\">雲服務（Cloud Services）\u003C/a>\u003C/li>\n\u003Cli>\u003Ca href=\"#tomcat-%E5%92%8C-jboss-%E6%9C%89%E4%BB%80%E9%BA%BC%E5%8D%80%E5%88%A5\">Tomcat 和 JBoss 有什麼區別？\u003C/a>\u003C/li>\n\u003Cli>\u003Ca href=\"#%E4%BB%80%E9%BA%BC%E4%BA%8B-%E8%A8%AD%E8%A8%88%E6%A8%A1%E5%BC%8Fdesign-pattern\">什麼事 設計模式（Design Pattern）?\u003C/a>\n\u003Cul>\n\u003Cli>\u003Ca href=\"#1%E5%89%B5%E5%BB%BA%E5%9E%8B%E6%A8%A1%E5%BC%8Fcreational-patterns\">1.創建型模式（Creational Patterns）\u003C/a>\u003C/li>\n\u003Cli>\u003Ca href=\"#2%E7%B5%90%E6%A7%8B%E5%9E%8B%E6%A8%A1%E5%BC%8Fstructural-patterns\">2.結構型模式（Structural Patterns）\u003C/a>\u003C/li>\n\u003Cli>\u003Ca href=\"#3%E8%A1%8C%E7%82%BA%E5%9E%8B%E6%A8%A1%E5%BC%8Fbehavioral-patterns\">3.行為型模式（Behavioral Patterns）\u003C/a>\u003C/li>\n\u003C/ul>\n\u003C/li>\n\u003C/ul>\n\u003Ch2 id=\"什麼是-oop-物件導向\">什麼是 OOP 物件導向？\u003C/h2>\n\u003Cul>\n\u003Cli>封裝\u003C/li>\n\u003Cli>繼承\u003C/li>\n\u003Cli>多型\u003C/li>\n\u003C/ul>\n\u003Ch2 id=\"spring-framework\">Spring framework\u003C/h2>\n\u003Cul>\n\u003Cli>Spring 是一個開源的應用框架，旨在簡化 Java 應用程式的開發，提供控制反轉（IoC）和依賴注入（DI）等功能。\u003C/li>\n\u003C/ul>\n\u003Col>\n\u003Cli>控制反轉 (IoC)\n\u003Cul>\n\u003Cli>什麼是 IoC ？\n\u003Cul>\n\u003Cli>IoC 容器負責管理對象的生命週期和依賴關係。\u003C/li>\n\u003C/ul>\n\u003C/li>\n\u003C/ul>\n\u003C/li>\n\u003Cli>依賴注入（DI）\n\u003Cul>\n\u003Cli>什麼是 DI？\n\u003Cul>\n\u003Cli>依賴注入是一種設計模式，通過將對象的依賴關係在運行時注入到對象中來減少耦合。\u003C/li>\n\u003C/ul>\n\u003C/li>\n\u003C/ul>\n\u003C/li>\n\u003Cli>AOP (面向切面編程)\n\u003Cul>\n\u003Cli>什麼是 AOP？\n\u003Cul>\n\u003Cli>AOP 是一種編程範式，用於將橫切關心（如日誌、安全性）與業務邏輯分離。\u003C/li>\n\u003C/ul>\n\u003C/li>\n\u003C/ul>\n\u003C/li>\n\u003C/ol>\n\u003Ch2 id=\"什麼是-spring-boot\">什麼是 Spring Boot？\u003C/h2>\n\u003Cul>\n\u003Cli>Spring Boot 是 Spring 的延伸，目標是讓開發者能夠快速建立 Spring 應用程式，而不需要處理大量的配置。它內建 Web 伺服器、自動配置、簡化依賴管理，適合用來開發 微服務（Microservices） 或 獨立應用。\u003C/li>\n\u003Cli>理解核心概念：熟悉 IoC（控制反轉）、DI（依賴注入）、AOP（面向切面編程）等基礎知識。\u003C/li>\n\u003C/ul>\n\u003Ch2 id=\"jpa-是什麼\">JPA 是什麼？\u003C/h2>\n\u003Cblockquote>\n\u003Cp>一個 ORM 的規範，不包含具體實作。\u003Cbr>\n通過映射 Java 物件與資料庫表格，使開發者能夠輕鬆處理資料庫操作。核心包括 EntityManager、JPQL、事務管理 等，能大幅簡化 Java 應用中的資料持久化工作，\u003Cbr>\n並且能與不同的 ORM 實現（如 Hibernate）兼容。\u003C/p>\n\u003C/blockquote>\n\u003Col>\n\u003Cli>\u003Cstrong>EntityManager\u003C/strong>：JPA 的核心介面，負責對實體進行 CRUD 操作。\u003C/li>\n\u003Cli>\u003Cstrong>JPQL（Java Persistence Query Language）\u003C/strong>：類似 SQL 的查詢語言，但基於 Java 實體而非資料庫表。\u003C/li>\n\u003Cli>\u003Cstrong>事務管理（Transaction Management）\u003C/strong>：JPA 支援透過 @Transactional 來管理事務，確保資料一致性。\u003C/li>\n\u003Cli>\u003Cstrong>不同的實現\u003C/strong>：JPA 只是規範，常見的實作有 Hibernate、EclipseLink、OpenJPA 等。\u003C/li>\n\u003C/ol>\n\u003Ch3 id=\"orm-是什麼\">ORM 是什麼？\u003C/h3>\n\u003Cblockquote>\n\u003Cp>JPA（Java Persistence API） – 規範\u003C/p>\n\u003C/blockquote>\n\u003Cpre class=\"astro-code github-dark\" style=\"background-color:#24292e;color:#e1e4e8; overflow-x: auto;\" tabindex=\"0\" data-language=\"plaintext\">\u003Ccode>\u003Cspan class=\"line\">\u003Cspan>Spring Data JPA － Spring 提供的一個數據訪問抽象\u003C/span>\u003C/span>\n\u003Cspan class=\"line\">\u003Cspan>Hibernate – 最流行的 JPA 實作，ORM 實作\u003C/span>\u003C/span>\n\u003Cspan class=\"line\">\u003Cspan>MyBatis – SQL Mapper\u003C/span>\u003C/span>\n\u003Cspan class=\"line\">\u003Cspan>OpenJPA – JPA 另一種實作\u003C/span>\u003C/span>\n\u003Cspan class=\"line\">\u003Cspan>EclipseLink – JPA 官方參考實作\u003C/span>\u003C/span>\u003C/code>\u003C/pre>\n\u003Ch4 id=\"spring-jdbc\">Spring JDBC\u003C/h4>\n\u003Cul>\n\u003Cli>概念：提供直接訪問數據庫的方式，使用 JdbcTemplate 類來執行 SQL 語句，並映射查詢結果。\u003C/li>\n\u003C/ul>\n\u003Ch4 id=\"spring-data-jpa\">Spring Data JPA\u003C/h4>\n\u003Cul>\n\u003Cli>JPA 抽象層，簡化數據訪問\u003C/li>\n\u003Cli>自動生成查詢，靈活度稍低\u003C/li>\n\u003Cli>項目與 Spring 生態系統深度集成。\u003C/li>\n\u003C/ul>\n\u003Ch4 id=\"hibernate\">Hibernate\u003C/h4>\n\u003Cul>\n\u003Cli>具體的 ORM 實作\u003C/li>\n\u003Cli>手寫 HQL/SQL，靈活度高\u003C/li>\n\u003Cli>使用 Hibernate 原生的 HQL、Criteria API 或原生 SQL\u003C/li>\n\u003C/ul>\n\u003Ch4 id=\"mybatis\">MyBatis\u003C/h4>\n\u003Cul>\n\u003Cli>SQL Mapper（SQL 映射工具）\u003C/li>\n\u003Cli>需要完全控制 SQL 語句。\u003C/li>\n\u003Cli>項目中存在大量複雜查詢或性能優化需求。\u003C/li>\n\u003Cli>需寫 XML\u003C/li>\n\u003C/ul>\n\u003Ch2 id=\"redis\">Redis\u003C/h2>\n\u003Col>\n\u003Cli>主要用途：Redis 是一個內存型數據存儲系統，主要用於快取、即時分析和簡單的消息系統。\u003C/li>\n\u003Cli>數據結構支持：支持多種數據結構（如字符串、哈希、列表、集合、有序集合等），靈活處理不同類型的數據。\u003C/li>\n\u003Cli>高性能：基於內存操作，讀寫速度極快，適合需要低延遲的場景。\u003C/li>\n\u003Cli>Pub/Sub 模型：提供基本的發布/訂閱功能，但不具備 RabbitMQ 的高級功能（如持久化和路由）。\u003C/li>\n\u003Cli>多功能性：除了作為消息系統，還可用作快取層、會話存儲或即時分析工具。\u003C/li>\n\u003C/ol>\n\u003Ch2 id=\"語法相關問題\">語法相關問題\u003C/h2>\n\u003Ch4 id=\"-和-equals-的區別\">== 和 .equals() 的區別？\u003C/h4>\n\u003Cul>\n\u003Cli>== 比較的是 記憶體地址（基本類型、引用類型）。\u003C/li>\n\u003Cli>.equals() 預設等價於 ==，但在 String 和 Integer 等類中 被重寫，比較的是內容。\u003C/li>\n\u003C/ul>\n\u003Ch4 id=\"java-中-final-finally-finalize-的區別\">Java 中 final, finally, finalize 的區別？\u003C/h4>\n\u003Cul>\n\u003Cli>final：用於 變數、方法、類，不可變或不可重寫。\u003C/li>\n\u003Cli>finally：用於 try-catch-finally，確保程式塊執行。\u003C/li>\n\u003Cli>\u003Cdel>finalize()：垃圾回收前執行，已被淘汰（JDK 9 棄用）。\u003C/del>\u003C/li>\n\u003C/ul>\n\u003Ch4 id=\"string-stringbuilder-stringbuffer-的區別\">String, StringBuilder, StringBuffer 的區別 ?\u003C/h4>\n\u003Cul>\n\u003Cli>String - String Pool（字串池機制）\n\u003Cul>\n\u003Cli>❌ 不可變\u003C/li>\n\u003Cli>✅ 安全（不可變）\u003C/li>\n\u003Cli>字串不會頻繁變化\u003C/li>\n\u003C/ul>\n\u003C/li>\n\u003Cli>StringBuilder\n\u003Cul>\n\u003Cli>✅ 可變\u003C/li>\n\u003Cli>❌ 不安全\u003C/li>\n\u003Cli>單執行緒、大量字串操作\u003C/li>\n\u003C/ul>\n\u003C/li>\n\u003Cli>StringBuffer\n\u003Cul>\n\u003Cli>✅ 可變\u003C/li>\n\u003Cli>✅ 安全（同步鎖）\u003C/li>\n\u003Cli>多執行緒、大量字串操作\u003C/li>\n\u003C/ul>\n\u003C/li>\n\u003C/ul>\n\u003Ch4 id=\"int--integer-差別\">int &#x26; integer 差別?\u003C/h4>\n\u003Cul>\n\u003Cli>基本資料類型 vs 物件類型\u003C/li>\n\u003C/ul>\n\u003Ch4 id=\"java-8-引入的流stream是什麼\">Java 8 引入的流（Stream）是什麼？\u003C/h4>\n\u003Cul>\n\u003Cli>更高效的集合操作方式，如過濾、映射、排序等。\u003C/li>\n\u003C/ul>\n\u003Ch4 id=\"什麼是-lambda-表達式有什麼優點\">什麼是 Lambda 表達式？有什麼優點？\u003C/h4>\n\u003Cul>\n\u003Cli>一種簡化函數式編程的方式，使得代碼更加簡潔。\u003C/li>\n\u003C/ul>\n\u003Ch4 id=\"什麼是集合\">什麼是集合？\u003C/h4>\n\u003Cul>\n\u003Cli>List 可重複，有序\n\u003Cul>\n\u003Cli>ArrayList（動態陣列，查詢快，增刪慢）\u003C/li>\n\u003Cli>LinkedList（鏈結串列，增刪快，查詢慢）\u003C/li>\n\u003Cli>Vector（類似 ArrayList，但執行緒安全）\u003C/li>\n\u003C/ul>\n\u003C/li>\n\u003Cli>Set 不可重複，無序\n\u003Cul>\n\u003Cli>HashSet（基於 HashTable，不保證順序）\u003C/li>\n\u003Cli>TreeSet（基於 紅黑樹，元素有序）\u003C/li>\n\u003Cli>LinkedHashSet（維持插入順序）\u003C/li>\n\u003C/ul>\n\u003C/li>\n\u003Cli>Map （Key-Value)\n\u003Cul>\n\u003Cli>HashMap（最快，但無序）\u003C/li>\n\u003Cli>TreeMap（Key 有序）\u003C/li>\n\u003Cli>LinkedHashMap（維持插入順序）\u003C/li>\n\u003C/ul>\n\u003C/li>\n\u003C/ul>\n\u003Ch4 id=\"待處理\">－－－待處理\u003C/h4>\n\u003Ch4 id=\"多執行緒和併發問題\">多執行緒和併發問題\u003C/h4>\n\u003Ch4 id=\"synchronized-和-lock-的區別\">synchronized 和 Lock 的區別？\u003C/h4>\n\u003Cul>\n\u003Cli>synchronized：內建鎖，自動釋放，效能較低。\u003C/li>\n\u003Cli>Lock（如 ReentrantLock）：手動釋放，支援可重入、超時等待、公平鎖等特性。\u003C/li>\n\u003C/ul>\n\u003Ch4 id=\"jvm\">JVM?\u003C/h4>\n\u003Ch2 id=\"微服務microservices\">微服務（Microservices）\u003C/h2>\n\u003Cblockquote>\n\u003Cp>微服務是一種架構模式\u003C/p>\n\u003C/blockquote>\n\u003Cul>\n\u003Cli>每個微服務都是獨立的，可以獨立開發、測試、部署。\u003C/li>\n\u003Cli>Spring Boot / Spring Cloud：用於快速開發和集成微服務的框架。\u003C/li>\n\u003Cli>Docker：提供容器化環境來部署微服務，確保每個微服務可以在任何環境中一致運行。\u003C/li>\n\u003Cli>Kubernetes：提供容器編排平台，用於管理微服務的部署、擴展和運行。\u003C/li>\n\u003C/ul>\n\u003Ch2 id=\"雲服務cloud-services\">雲服務（Cloud Services）\u003C/h2>\n\u003Cul>\n\u003Cli>Amazon Web Services (AWS)：\n\u003Cul>\n\u003Cli>全球最大的雲服務提供商，提供各種 IaaS、PaaS 和 SaaS 服務，涵蓋計算、存儲、網絡、人工智能等領域。\u003C/li>\n\u003C/ul>\n\u003C/li>\n\u003Cli>Microsoft Azure：\n\u003Cul>\n\u003Cli>微軟的雲平台，提供全面的雲計算服務，並與微軟的企業軟件（如 Windows Server、SQL Server）無縫集成。\u003C/li>\n\u003C/ul>\n\u003C/li>\n\u003Cli>IBM Cloud：\n\u003Cul>\n\u003Cli>IBM 提供的雲服務平台，專注於企業級解決方案，支持 AI、機器學習、區塊鏈等技術。\u003C/li>\n\u003C/ul>\n\u003C/li>\n\u003C/ul>\n\u003Ch2 id=\"tomcat-和-jboss-有什麼區別\">Tomcat 和 JBoss 有什麼區別？\u003C/h2>\n\u003Cul>\n\u003Cli>Tomcat：\n\u003Cul>\n\u003Cli>Tomcat 是一個 Web 伺服器 和 Servlet 容器，Tomcat 適合用於需要輕量級的 Web 應用部署和運行，適合簡單的 Servlet/JSP 應用。\u003C/li>\n\u003C/ul>\n\u003C/li>\n\u003Cli>JBoss（現名為 WildFly）：\n\u003Cul>\n\u003Cli>JBoss 提供了一個完整的企業級解決方案，支持分佈式架構、事務處理和消息驅動等功能，適合大型企業應用和多層架構。\u003C/li>\n\u003Cli>提供了對 EJB、JPA、JMS、JTA 等企業級技術的完整支援，適用於開發和部署企業級應用\u003C/li>\n\u003C/ul>\n\u003C/li>\n\u003C/ul>\n\u003Cp>| Java EE 的核心技術                       | 說明                                            |\n| ---------------------------------------- | ----------------------------------------------- | ----------- |\n| Servlet                                  | 負責處理 HTTP 請求和回應，動態產生網頁內容      |\n| JSP（JavaServer Pages）                  | 讓開發者能在 HTML 中嵌入 Java 代碼              |\n| JSF（JavaServer Faces）                  | 企業級 Web UI 框架，類似於 Angular / React      |\n| JPA（Java Persistence API）              | ORM 框架，用來管理數據庫（類似                  | Hibernate） |\n| JTA（Java Transaction API）              | 負責分散式交易管理（確保資料一致性）            |\n| EJB（Enterprise JavaBeans）              | 負責商業邏輯，支援事務管理                      |\n| JMS（Java Message Service）              | 提供訊息佇列（Message Queue）功能               |\n| CDI（Contexts and Dependency Injection） | 依賴注入（類似 Spring 的 Dependency Injection） |\u003C/p>\n\u003Chr>\n\u003Ch2 id=\"什麼事-設計模式design-pattern\">什麼事 設計模式（Design Pattern）?\u003C/h2>\n\u003Cp>計模式通常分為三大類：\u003C/p>\n\u003Ch3 id=\"1創建型模式creational-patterns\">1.創建型模式（Creational Patterns）\u003C/h3>\n\u003Cblockquote>\n\u003Cp>這些模式主要解決如何將對象或類組合成更大的結構，以達到更好的效率和更清晰的代碼結構。\u003C/p>\n\u003C/blockquote>\n\u003Cul>\n\u003Cli>🔴 單例模式（Singleton Pattern）：\n\u003Cul>\n\u003Cli>保證一個類只有一個實例，並提供一個全局的訪問點。\u003C/li>\n\u003C/ul>\n\u003C/li>\n\u003Cli>🔴 工廠方法模式（Factory Method Pattern）：\n\u003Cul>\n\u003Cli>定義一個用於創建對象的接口，讓子類決定具體實例化哪一個類。\u003C/li>\n\u003C/ul>\n\u003C/li>\n\u003Cli>🔴 抽象工廠模式（Abstract Factory Pattern）：\n\u003Cul>\n\u003Cli>提供一個創建一系列相關或相互依賴對象的接口，而無需指定具體類別。\u003C/li>\n\u003C/ul>\n\u003C/li>\n\u003Cli>建造者模式（Builder Pattern）：\n\u003Cul>\n\u003Cli>分步構建一個複雜的對象，將對象的構建過程與表示分離。\u003C/li>\n\u003C/ul>\n\u003C/li>\n\u003Cli>原型模式（Prototype Pattern）：\n\u003Cul>\n\u003Cli>通過複製現有的對象來創建新對象，而不是重新創建一個對象。\u003C/li>\n\u003C/ul>\n\u003C/li>\n\u003C/ul>\n\u003Ch3 id=\"2結構型模式structural-patterns\">2.結構型模式（Structural Patterns）\u003C/h3>\n\u003Cblockquote>\n\u003Cp>這些模式主要解決如何將對象或類組合成更大的結構，以達到更好的效率和更清晰的代碼結構。\u003C/p>\n\u003C/blockquote>\n\u003Cul>\n\u003Cli>適配器模式（Adapter Pattern）：\n\u003Cul>\n\u003Cli>將一個類的接口轉換為客戶端所期望的另一種接口，讓原本接口不兼容的類可以合作無間。\u003C/li>\n\u003C/ul>\n\u003C/li>\n\u003Cli>裝飾者模式（Decorator Pattern）：\n\u003Cul>\n\u003Cli>動態地給一個對象添加額外的職責，提供比繼承更靈活的擴展機會。\u003C/li>\n\u003C/ul>\n\u003C/li>\n\u003Cli>外觀模式（Facade Pattern）：\n\u003Cul>\n\u003Cli>為一組接口提供一個統一的高層接口，使得子系統的使用者可以更容易地使用這些接口。\u003C/li>\n\u003C/ul>\n\u003C/li>\n\u003Cli>橋接模式（Bridge Pattern）：\n\u003Cul>\n\u003Cli>將抽象部分與實現部分分離，使得兩者可以獨立變化。\u003C/li>\n\u003C/ul>\n\u003C/li>\n\u003Cli>組合模式（Composite Pattern）：\n\u003Cul>\n\u003Cli>將對象組合成樹形結構來表示部分與整體的層次結構，讓客戶對單個物件和組合物件的使用具有一致性。\u003C/li>\n\u003C/ul>\n\u003C/li>\n\u003Cli>享元模式（Flyweight Pattern）：\n\u003Cul>\n\u003Cli>通過共享相同的對象來減少內存消耗，特別是在處理大量細粒度對象的情況下。\u003C/li>\n\u003C/ul>\n\u003C/li>\n\u003C/ul>\n\u003Ch3 id=\"3行為型模式behavioral-patterns\">3.行為型模式（Behavioral Patterns）\u003C/h3>\n\u003Cblockquote>\n\u003Cp>這些模式主要關心對象或類之間的通信和交互，如何提高對象之間協作的靈活性和效率。\u003C/p>\n\u003C/blockquote>\n\u003Cul>\n\u003Cli>🔴 策略模式（Strategy Pattern）：\n\u003Cul>\n\u003Cli>定義一系列的算法，並將每個算法封裝起來，使得它們可以互換，讓算法的變化獨立於使用算法的客戶。\u003C/li>\n\u003C/ul>\n\u003C/li>\n\u003Cli>模板方法模式（Template Method Pattern）：\n\u003Cul>\n\u003Cli>定義一個操作中的算法骨架，將某些步驟延遲到子類中，使得子類可以重新定義某些算法步驟而不改變算法的結構。\u003C/li>\n\u003C/ul>\n\u003C/li>\n\u003Cli>觀察者模式（Observer Pattern）：\n\u003Cul>\n\u003Cli>定義了一種一對多的依賴關係，當一個對象改變狀態時，所有依賴於它的對象都會得到通知並自動更新。\u003C/li>\n\u003C/ul>\n\u003C/li>\n\u003Cli>狀態模式（State Pattern）：\n\u003Cul>\n\u003Cli>允許對象在其內部狀態改變時改變其行為，使得對象的行為會根據當前狀態來改變。\u003C/li>\n\u003C/ul>\n\u003C/li>\n\u003Cli>責任鏈模式（Chain of Responsibility Pattern）：\n\u003Cul>\n\u003Cli>為請求創建一個接收者的鏈，每個接收者都對請求做出處理或轉發，直到請求被處理為止。\u003C/li>\n\u003C/ul>\n\u003C/li>\n\u003Cli>命令模式（Command Pattern）：\n\u003Cul>\n\u003Cli>將請求封裝成對象，從而讓用戶對請求的發出者和接收者解耦。\u003C/li>\n\u003C/ul>\n\u003C/li>\n\u003Cli>中介者模式（Mediator Pattern）：\n\u003Cul>\n\u003Cli>定義一個對象來封裝一組對象之間的交互，使得這些對象不需要直接互相引用，從而使它們的耦合度降低。\u003C/li>\n\u003C/ul>\n\u003C/li>\n\u003C/ul>",{"headings":152,"imagePaths":216,"frontmatter":217},[153,157,158,159,160,161,163,164,165,166,167,169,172,175,178,181,184,187,190,193,195,198,201,202,203,204,207,210,213],{"depth":154,"slug":155,"text":156},2,"什麼是-oop-物件導向","什麼是 OOP 物件導向？",{"depth":154,"slug":75,"text":76},{"depth":154,"slug":78,"text":79},{"depth":154,"slug":81,"text":82},{"depth":34,"slug":84,"text":85},{"depth":162,"slug":87,"text":88},4,{"depth":162,"slug":90,"text":91},{"depth":162,"slug":93,"text":94},{"depth":162,"slug":96,"text":97},{"depth":154,"slug":99,"text":100},{"depth":154,"slug":168,"text":168},"語法相關問題",{"depth":162,"slug":170,"text":171},"-和-equals-的區別","== 和 .equals() 的區別？",{"depth":162,"slug":173,"text":174},"java-中-final-finally-finalize-的區別","Java 中 final, finally, finalize 的區別？",{"depth":162,"slug":176,"text":177},"string-stringbuilder-stringbuffer-的區別","String, StringBuilder, StringBuffer 的區別 ?",{"depth":162,"slug":179,"text":180},"int--integer-差別","int & integer 差別?",{"depth":162,"slug":182,"text":183},"java-8-引入的流stream是什麼","Java 8 引入的流（Stream）是什麼？",{"depth":162,"slug":185,"text":186},"什麼是-lambda-表達式有什麼優點","什麼是 Lambda 表達式？有什麼優點？",{"depth":162,"slug":188,"text":189},"什麼是集合","什麼是集合？",{"depth":162,"slug":191,"text":192},"待處理","－－－待處理",{"depth":162,"slug":194,"text":194},"多執行緒和併發問題",{"depth":162,"slug":196,"text":197},"synchronized-和-lock-的區別","synchronized 和 Lock 的區別？",{"depth":162,"slug":199,"text":200},"jvm","JVM?",{"depth":154,"slug":105,"text":106},{"depth":154,"slug":108,"text":109},{"depth":154,"slug":102,"text":103},{"depth":154,"slug":205,"text":206},"什麼事-設計模式design-pattern","什麼事 設計模式（Design Pattern）?",{"depth":34,"slug":208,"text":209},"1創建型模式creational-patterns","1.創建型模式（Creational Patterns）",{"depth":34,"slug":211,"text":212},"2結構型模式structural-patterns","2.結構型模式（Structural Patterns）",{"depth":34,"slug":214,"text":215},"3行為型模式behavioral-patterns","3.行為型模式（Behavioral Patterns）",[],{"title":138,"author":17,"description":140,"image":218,"pubDate":219,"tags":220},{"url":142,"alt":143},["Date","2022-07-08T00:00:00.000Z"],[22,145,23,122],"post-1",{"id":221,"data":223,"body":230,"filePath":231,"digest":232,"rendered":233},{"title":224,"pubDate":225,"description":140,"author":17,"image":226,"tags":229},"Notes-for-Java",["Date","2022-07-01T00:00:00.000Z"],{"url":227,"alt":228},"https://docs.astro.build/assets/rose.webp","The Astro logo on a dark background with a pink glow.",[22,145,23],"- [標題](#標題)\n- [字型](#字型)\n- [項目清單表示法【\\*】【-】【+】](#項目清單表示法-)\n- [分隔線](#分隔線)\n- [引言](#引言)\n- [程式碼區塊](#程式碼區塊)\n- [超連結](#超連結)\n- [跳脫字元](#跳脫字元)\n- [換行法](#換行法)\n- [表格](#表格)\n- [大綱產生方法](#大綱產生方法)\n- [other](#other)\n\n## 標題\n\n```\n# 標題一\n## 標題二\n###  標題三\n#### 標題四\n##### 標題五\n###### 標題六\n\nThis is an H1\n=============\n\nThis is an H2\n-------------\n```\n\n## 字型\n\n**粗體** `**粗體**`  \n_斜體_ `_斜體_`  \n~~刪除線~~ `~~刪除線~~`\n\n## 項目清單表示法【\\*】【-】【+】\n\n- 第一個 `* 第一個`\n\n* 第二個 `- 第二個`\n\n- 第三個 `+ 第三個`\n\n1. 第一個 `1. 第一個`\n2. 第二個 `2. 第二個`\n3. 第三個 `3. 第三個`\n\n## 分隔線\n\n```\n***\n* * *\n---\n- - -\n```\n\n---\n\n---\n\n---\n\n---\n\n## 引言\n\n```\n> 測試測試測試測試\n>> 測試測試測試測試\n>>> 測試測試測試測試\n>>>> 測試測試測試測試\n>>>>> 測試測試測試測試\n```\n\n> 測試測試測試測試\n>\n> > 測試測試測試測試\n> >\n> > > 測試測試測試測試\n> > >\n> > > > 測試測試測試測試\n> > > >\n> > > > > 測試測試測試測試\n\n## 程式碼區塊\n\n```json\n{ \"name\": \"Vivi\", \"age\": 32, \"phone\": null }\n```\n\n```html\n\u003Cscript type=\"text/javascript\">\n  alert(\"Hello\");\n\u003C/script>\n```\n\n## 超連結\n\n[name](url)\n\n## 跳脫字元\n\n\\\n\n## 換行法\n\n```\n句尾打兩個空格...\n句尾打 \\\n句尾打 \u003Cbr>\n```\n\n## 表格\n\n| 表头   | 表头   |\n| ------ | ------ |\n| 单元格 | 单元格 |\n| 单元格 | 单元格 |\n\n| 左对齐 | 右对齐 | 居中对齐 |\n| :----- | -----: | :------: |\n| 单元格 | 单元格 |  单元格  |\n| 单元格 | 单元格 |  单元格  |\n\n## 大綱產生方法\n\n快捷鍵 ＋Ｐ 收尋：\n\n> Markdown All in One:reate Table of Contents\n\n## other\n\nhttps://markdown.tw\nhttps://www.runoob.com/markdown/md-tutorial.html","src/blog/post-1.md","c09d29534d9f55ea",{"html":234,"metadata":235},"\u003Cul>\n\u003Cli>\u003Ca href=\"#%E6%A8%99%E9%A1%8C\">標題\u003C/a>\u003C/li>\n\u003Cli>\u003Ca href=\"#%E5%AD%97%E5%9E%8B\">字型\u003C/a>\u003C/li>\n\u003Cli>\u003Ca href=\"#%E9%A0%85%E7%9B%AE%E6%B8%85%E5%96%AE%E8%A1%A8%E7%A4%BA%E6%B3%95-\">項目清單表示法【*】【-】【+】\u003C/a>\u003C/li>\n\u003Cli>\u003Ca href=\"#%E5%88%86%E9%9A%94%E7%B7%9A\">分隔線\u003C/a>\u003C/li>\n\u003Cli>\u003Ca href=\"#%E5%BC%95%E8%A8%80\">引言\u003C/a>\u003C/li>\n\u003Cli>\u003Ca href=\"#%E7%A8%8B%E5%BC%8F%E7%A2%BC%E5%8D%80%E5%A1%8A\">程式碼區塊\u003C/a>\u003C/li>\n\u003Cli>\u003Ca href=\"#%E8%B6%85%E9%80%A3%E7%B5%90\">超連結\u003C/a>\u003C/li>\n\u003Cli>\u003Ca href=\"#%E8%B7%B3%E8%84%AB%E5%AD%97%E5%85%83\">跳脫字元\u003C/a>\u003C/li>\n\u003Cli>\u003Ca href=\"#%E6%8F%9B%E8%A1%8C%E6%B3%95\">換行法\u003C/a>\u003C/li>\n\u003Cli>\u003Ca href=\"#%E8%A1%A8%E6%A0%BC\">表格\u003C/a>\u003C/li>\n\u003Cli>\u003Ca href=\"#%E5%A4%A7%E7%B6%B1%E7%94%A2%E7%94%9F%E6%96%B9%E6%B3%95\">大綱產生方法\u003C/a>\u003C/li>\n\u003Cli>\u003Ca href=\"#other\">other\u003C/a>\u003C/li>\n\u003C/ul>\n\u003Ch2 id=\"標題\">標題\u003C/h2>\n\u003Cpre class=\"astro-code github-dark\" style=\"background-color:#24292e;color:#e1e4e8; overflow-x: auto;\" tabindex=\"0\" data-language=\"plaintext\">\u003Ccode>\u003Cspan class=\"line\">\u003Cspan># 標題一\u003C/span>\u003C/span>\n\u003Cspan class=\"line\">\u003Cspan>## 標題二\u003C/span>\u003C/span>\n\u003Cspan class=\"line\">\u003Cspan>###  標題三\u003C/span>\u003C/span>\n\u003Cspan class=\"line\">\u003Cspan>#### 標題四\u003C/span>\u003C/span>\n\u003Cspan class=\"line\">\u003Cspan>##### 標題五\u003C/span>\u003C/span>\n\u003Cspan class=\"line\">\u003Cspan>###### 標題六\u003C/span>\u003C/span>\n\u003Cspan class=\"line\">\u003Cspan>\u003C/span>\u003C/span>\n\u003Cspan class=\"line\">\u003Cspan>This is an H1\u003C/span>\u003C/span>\n\u003Cspan class=\"line\">\u003Cspan>=============\u003C/span>\u003C/span>\n\u003Cspan class=\"line\">\u003Cspan>\u003C/span>\u003C/span>\n\u003Cspan class=\"line\">\u003Cspan>This is an H2\u003C/span>\u003C/span>\n\u003Cspan class=\"line\">\u003Cspan>-------------\u003C/span>\u003C/span>\u003C/code>\u003C/pre>\n\u003Ch2 id=\"字型\">字型\u003C/h2>\n\u003Cp>\u003Cstrong>粗體\u003C/strong> \u003Ccode>**粗體**\u003C/code>\u003Cbr>\n\u003Cem>斜體\u003C/em> \u003Ccode>_斜體_\u003C/code>\u003Cbr>\n\u003Cdel>刪除線\u003C/del> \u003Ccode>~~刪除線~~\u003C/code>\u003C/p>\n\u003Ch2 id=\"項目清單表示法\">項目清單表示法【*】【-】【+】\u003C/h2>\n\u003Cul>\n\u003Cli>第一個 \u003Ccode>* 第一個\u003C/code>\u003C/li>\n\u003C/ul>\n\u003Cul>\n\u003Cli>第二個 \u003Ccode>- 第二個\u003C/code>\u003C/li>\n\u003C/ul>\n\u003Cul>\n\u003Cli>第三個 \u003Ccode>+ 第三個\u003C/code>\u003C/li>\n\u003C/ul>\n\u003Col>\n\u003Cli>第一個 \u003Ccode>1. 第一個\u003C/code>\u003C/li>\n\u003Cli>第二個 \u003Ccode>2. 第二個\u003C/code>\u003C/li>\n\u003Cli>第三個 \u003Ccode>3. 第三個\u003C/code>\u003C/li>\n\u003C/ol>\n\u003Ch2 id=\"分隔線\">分隔線\u003C/h2>\n\u003Cpre class=\"astro-code github-dark\" style=\"background-color:#24292e;color:#e1e4e8; overflow-x: auto;\" tabindex=\"0\" data-language=\"plaintext\">\u003Ccode>\u003Cspan class=\"line\">\u003Cspan>***\u003C/span>\u003C/span>\n\u003Cspan class=\"line\">\u003Cspan>* * *\u003C/span>\u003C/span>\n\u003Cspan class=\"line\">\u003Cspan>---\u003C/span>\u003C/span>\n\u003Cspan class=\"line\">\u003Cspan>- - -\u003C/span>\u003C/span>\u003C/code>\u003C/pre>\n\u003Chr>\n\u003Chr>\n\u003Chr>\n\u003Chr>\n\u003Ch2 id=\"引言\">引言\u003C/h2>\n\u003Cpre class=\"astro-code github-dark\" style=\"background-color:#24292e;color:#e1e4e8; overflow-x: auto;\" tabindex=\"0\" data-language=\"plaintext\">\u003Ccode>\u003Cspan class=\"line\">\u003Cspan>> 測試測試測試測試\u003C/span>\u003C/span>\n\u003Cspan class=\"line\">\u003Cspan>>> 測試測試測試測試\u003C/span>\u003C/span>\n\u003Cspan class=\"line\">\u003Cspan>>>> 測試測試測試測試\u003C/span>\u003C/span>\n\u003Cspan class=\"line\">\u003Cspan>>>>> 測試測試測試測試\u003C/span>\u003C/span>\n\u003Cspan class=\"line\">\u003Cspan>>>>>> 測試測試測試測試\u003C/span>\u003C/span>\u003C/code>\u003C/pre>\n\u003Cblockquote>\n\u003Cp>測試測試測試測試\u003C/p>\n\u003Cblockquote>\n\u003Cp>測試測試測試測試\u003C/p>\n\u003Cblockquote>\n\u003Cp>測試測試測試測試\u003C/p>\n\u003Cblockquote>\n\u003Cp>測試測試測試測試\u003C/p>\n\u003Cblockquote>\n\u003Cp>測試測試測試測試\u003C/p>\n\u003C/blockquote>\n\u003C/blockquote>\n\u003C/blockquote>\n\u003C/blockquote>\n\u003C/blockquote>\n\u003Ch2 id=\"程式碼區塊\">程式碼區塊\u003C/h2>\n\u003Cpre class=\"astro-code github-dark\" style=\"background-color:#24292e;color:#e1e4e8; overflow-x: auto;\" tabindex=\"0\" data-language=\"json\">\u003Ccode>\u003Cspan class=\"line\">\u003Cspan style=\"color:#E1E4E8\">{ \u003C/span>\u003Cspan style=\"color:#79B8FF\">\"name\"\u003C/span>\u003Cspan style=\"color:#E1E4E8\">: \u003C/span>\u003Cspan style=\"color:#9ECBFF\">\"Vivi\"\u003C/span>\u003Cspan style=\"color:#E1E4E8\">, \u003C/span>\u003Cspan style=\"color:#79B8FF\">\"age\"\u003C/span>\u003Cspan style=\"color:#E1E4E8\">: \u003C/span>\u003Cspan style=\"color:#79B8FF\">32\u003C/span>\u003Cspan style=\"color:#E1E4E8\">, \u003C/span>\u003Cspan style=\"color:#79B8FF\">\"phone\"\u003C/span>\u003Cspan style=\"color:#E1E4E8\">: \u003C/span>\u003Cspan style=\"color:#79B8FF\">null\u003C/span>\u003Cspan style=\"color:#E1E4E8\"> }\u003C/span>\u003C/span>\u003C/code>\u003C/pre>\n\u003Cpre class=\"astro-code github-dark\" style=\"background-color:#24292e;color:#e1e4e8; overflow-x: auto;\" tabindex=\"0\" data-language=\"html\">\u003Ccode>\u003Cspan class=\"line\">\u003Cspan style=\"color:#E1E4E8\">&#x3C;\u003C/span>\u003Cspan style=\"color:#85E89D\">script\u003C/span>\u003Cspan style=\"color:#B392F0\"> type\u003C/span>\u003Cspan style=\"color:#E1E4E8\">=\u003C/span>\u003Cspan style=\"color:#9ECBFF\">\"text/javascript\"\u003C/span>\u003Cspan style=\"color:#E1E4E8\">>\u003C/span>\u003C/span>\n\u003Cspan class=\"line\">\u003Cspan style=\"color:#B392F0\">  alert\u003C/span>\u003Cspan style=\"color:#E1E4E8\">(\u003C/span>\u003Cspan style=\"color:#9ECBFF\">\"Hello\"\u003C/span>\u003Cspan style=\"color:#E1E4E8\">);\u003C/span>\u003C/span>\n\u003Cspan class=\"line\">\u003Cspan style=\"color:#E1E4E8\">&#x3C;/\u003C/span>\u003Cspan style=\"color:#85E89D\">script\u003C/span>\u003Cspan style=\"color:#E1E4E8\">>\u003C/span>\u003C/span>\u003C/code>\u003C/pre>\n\u003Ch2 id=\"超連結\">超連結\u003C/h2>\n\u003Cp>\u003Ca href=\"url\">name\u003C/a>\u003C/p>\n\u003Ch2 id=\"跳脫字元\">跳脫字元\u003C/h2>\n\u003Cp>\\\u003C/p>\n\u003Ch2 id=\"換行法\">換行法\u003C/h2>\n\u003Cpre class=\"astro-code github-dark\" style=\"background-color:#24292e;color:#e1e4e8; overflow-x: auto;\" tabindex=\"0\" data-language=\"plaintext\">\u003Ccode>\u003Cspan class=\"line\">\u003Cspan>句尾打兩個空格...\u003C/span>\u003C/span>\n\u003Cspan class=\"line\">\u003Cspan>句尾打 \\\u003C/span>\u003C/span>\n\u003Cspan class=\"line\">\u003Cspan>句尾打 &#x3C;br>\u003C/span>\u003C/span>\u003C/code>\u003C/pre>\n\u003Ch2 id=\"表格\">表格\u003C/h2>\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\u003Ctable>\u003Cthead>\u003Ctr>\u003Cth>表头\u003C/th>\u003Cth>表头\u003C/th>\u003C/tr>\u003C/thead>\u003Ctbody>\u003Ctr>\u003Ctd>单元格\u003C/td>\u003Ctd>单元格\u003C/td>\u003C/tr>\u003Ctr>\u003Ctd>单元格\u003C/td>\u003Ctd>单元格\u003C/td>\u003C/tr>\u003C/tbody>\u003C/table>\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\u003Ctable>\u003Cthead>\u003Ctr>\u003Cth align=\"left\">左对齐\u003C/th>\u003Cth align=\"right\">右对齐\u003C/th>\u003Cth align=\"center\">居中对齐\u003C/th>\u003C/tr>\u003C/thead>\u003Ctbody>\u003Ctr>\u003Ctd align=\"left\">单元格\u003C/td>\u003Ctd align=\"right\">单元格\u003C/td>\u003Ctd align=\"center\">单元格\u003C/td>\u003C/tr>\u003Ctr>\u003Ctd align=\"left\">单元格\u003C/td>\u003Ctd align=\"right\">单元格\u003C/td>\u003Ctd align=\"center\">单元格\u003C/td>\u003C/tr>\u003C/tbody>\u003C/table>\n\u003Ch2 id=\"大綱產生方法\">大綱產生方法\u003C/h2>\n\u003Cp>快捷鍵 ＋Ｐ 收尋：\u003C/p>\n\u003Cblockquote>\n\u003Cp>Markdown All in One:reate Table of Contents\u003C/p>\n\u003C/blockquote>\n\u003Ch2 id=\"other\">other\u003C/h2>\n\u003Cp>\u003Ca href=\"https://markdown.tw\">https://markdown.tw\u003C/a>\n\u003Ca href=\"https://www.runoob.com/markdown/md-tutorial.html\">https://www.runoob.com/markdown/md-tutorial.html\u003C/a>\u003C/p>",{"headings":236,"imagePaths":261,"frontmatter":262},[237,239,241,244,246,248,250,252,254,256,258,260],{"depth":154,"slug":238,"text":238},"標題",{"depth":154,"slug":240,"text":240},"字型",{"depth":154,"slug":242,"text":243},"項目清單表示法","項目清單表示法【*】【-】【+】",{"depth":154,"slug":245,"text":245},"分隔線",{"depth":154,"slug":247,"text":247},"引言",{"depth":154,"slug":249,"text":249},"程式碼區塊",{"depth":154,"slug":251,"text":251},"超連結",{"depth":154,"slug":253,"text":253},"跳脫字元",{"depth":154,"slug":255,"text":255},"換行法",{"depth":154,"slug":257,"text":257},"表格",{"depth":154,"slug":259,"text":259},"大綱產生方法",{"depth":154,"slug":56,"text":56},[],{"title":224,"pubDate":263,"description":140,"author":17,"image":264,"tags":265},["Date","2022-07-01T00:00:00.000Z"],{"url":227,"alt":228},[22,145,23]]